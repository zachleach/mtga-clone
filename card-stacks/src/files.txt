/* App.jsx */
import { useState, useEffect, useRef } from 'react'
import './remove_scrollbars.css'
import { BoardStateProvider, useBoardState } from './BoardState'

const Card = ({ color }) => {
  const card_style = {
    width: '100%',
    height: '100%',
    backgroundColor: color || 'white',
    border: '1px solid black',
    borderRadius: '12px',
  }

  return (
    <div style={card_style}/>
  )
}

/* layout component that also handles drag/drop of cards to/from it */
const CardStack = ({ card_arr, row, stack_id }) => {
  const { handlers, register_stack_ref } = useBoardState()
  const stack_ref = useRef(null)

  /* register ref on mount, clear on unmount */
  useEffect(() => {
    register_stack_ref(row, stack_id, stack_ref)
    return () => register_stack_ref(row, stack_id, null)
  }, [row, stack_id])

  const card_height = 140
  const overlap = 0.15
  const visible_height = card_height * overlap
  
  const stack_container_styling = {
    position: 'relative',
    height: `${((card_arr.length - 1) * visible_height) + card_height}px`,
    width: `${card_height * 0.714}px`,
    margin: `${card_height * 0.1}px`,
  }

  const get_position_styling = (index) => ({
    position: 'absolute',
    height: `${card_height}px`,
    width: '100%',
    top: `${index * card_height * overlap}px`,
    zIndex: index,
  })

  const html5_dnd_attributes = (index) => ({
    draggable: true,
    onDragStart: (e) => handlers.drag_start.cardstack(e, row, stack_id, index),
    onDrop: (e) => handlers.drop.cardstack(e, row, stack_id, index),
    onDragOver: (e) => handlers.drag_over.cardstack(e, index)
  })

  return (
    <div ref={stack_ref} style={stack_container_styling}>
      {card_arr.map((card, index) => (
        <div key={index} style={get_position_styling(index)} {...html5_dnd_attributes(index)} >
          <Card {...card} />
        </div>
      ))}
    </div>
  )
}

/* renders the stacks for a single row */
const CardRow = ({ row, row_position }) => {
  const { handlers } = useBoardState()

  const container_style = {
    height: '20%', 
    width: '100%', 
    background: 'grey',
    border: '1px solid black',
    boxSizing: 'border-box',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
  }

  const html5_dnd_attributes = {
    onDragOver: (e) => handlers.drag_over.cardrow(e, row_position),
    onDrop: (e) => handlers.drop.cardrow(e, row_position),
  }

  return (
    <div style={container_style} {...html5_dnd_attributes}>
      {row.stacks.map(stack => (
        <CardStack
          key={stack.id}
          card_arr={stack.cards}
          row={row_position}
          stack_id={stack.id}
        />
      ))}
    </div>
  )
}

/* renders the full board with three explicit rows */
const Board = () => {
  const { rows } = useBoardState()
  const [top_row, left_row, right_row] = rows

  const container_style = {
    display: 'flex',  
    height: '100vh',
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'column',
  }

  return (
    <div style={container_style}>
      <CardRow row={top_row} row_position="top" />
      <CardRow row={left_row} row_position="left" />
      <CardRow row={right_row} row_position="right" />
    </div>
  )
}

const App = () => {
  return (
    <BoardStateProvider>
      <Board/>
    </BoardStateProvider>
  )
}

export default App
/* BoardState.jsx */
import { createContext, useContext, useState, useRef } from 'react'

const BoardStateContext = createContext(null)

export const useBoardState = () => {
  const context = useContext(BoardStateContext)
  if (!context) {
    throw new Error('useBoardState must be used within a BoardStateProvider')
  }
  return context
}

/* valid row positions for type checking */
const ROW_POSITIONS = ['top', 'left', 'right']

export const BoardStateProvider = ({ children }) => {

	/* STATE */
	
  const create_initial_stack = () => ({
    id: '0',
    cards: [
      { color: 'red' }, 
      { color: 'blue' }, 
      { color: 'green' }, 
      { color: 'yellow' }
    ]
  })

  const [top_row, set_top_row] = useState({
    stacks: [create_initial_stack()]
  })
  
  const [left_row, set_left_row] = useState({
    stacks: [create_initial_stack()]
  })
  
  const [right_row, set_right_row] = useState({
    stacks: [create_initial_stack()]
  })

  const get_row_setter = (row) => {
    if (!ROW_POSITIONS.includes(row)) {
      throw new Error(`Invalid row position: ${row}`)
    }
    
    switch(row) {
      case 'top': return set_top_row
      case 'left': return set_left_row
      case 'right': return set_right_row
    }
  }

  const get_row_state = (row) => {
    if (!ROW_POSITIONS.includes(row)) {
      throw new Error(`Invalid row position: ${row}`)
    }

    switch(row) {
      case 'top': return top_row
      case 'left': return left_row
      case 'right': return right_row
    }
  }

  const get_unique_stack_id = (row_state) => {
    const used_ids = new Set(row_state.stacks.map(s => s.id))
    let new_id = 0
    while (used_ids.has(String(new_id))) new_id++
    return String(new_id)
  }













	/* REFS */

  const stack_refs = useRef({})
  const register_stack_ref = (row, stack_id, ref) => {
    if (!ROW_POSITIONS.includes(row)) {
      throw new Error(`Invalid row position: ${row}`)
    }
    
    const key = `${row}-${stack_id}`
    if (ref === null) {
      delete stack_refs.current[key]
    } else {
      stack_refs.current[key] = ref
    }
  }

  const get_stack_position = (row, stack_id) => {
    const key = `${row}-${stack_id}`
    const ref = stack_refs.current[key]
    if (!ref?.current) return null
    
    const rect = ref.current.getBoundingClientRect()
    return {
      left: rect.left,
      right: rect.right,
      width: rect.width,
      center: rect.left + (rect.width / 2)
    }
  }



	/* EVENT HANDLING */

  const handlers = {

		/* DRAG START */
    drag_start: {
      cardstack: (e, row, stack_id, card_index) => {
        e.dataTransfer.setData('source', JSON.stringify({
          row,
          stack_id,
          card_index
        }))
      }
    },


		/* DROP EVENTS */
    drop: {
      cardstack: (e, target_row, target_stack_id, target_index) => {
        e.preventDefault()
        e.stopPropagation()

        const source = JSON.parse(e.dataTransfer.getData('source'))
        move_card(source, {
          row: target_row,
          stack_id: target_stack_id,
          card_index: target_index
        })
      },

      cardrow: (e, target_row) => {
        e.preventDefault()
        const source = JSON.parse(e.dataTransfer.getData('source'))
        move_card(source, {
          row: target_row,
          stack_id: null,
          drop_x: e.clientX
        })
      }
    },

		/* DRAG OVER */
    drag_over: {
      cardstack: (e) => {
        e.preventDefault()
        e.stopPropagation()
      },

      cardrow: (e) => {
        e.preventDefault()
      }
    }
  }





  /* handle moving a card between or within rows */
  const move_card = (source, target) => {
    const source_row = get_row_state(source.row)
    const source_setter = get_row_setter(source.row)
    const target_setter = get_row_setter(target.row)
    
    /* store the moved card so it's available for both state updates */
    let moved_card = null

    /* remove card from source */
    source_setter(curr_state => {
      const updated_state = { ...curr_state }
      const source_stack = updated_state.stacks.find(s => s.id === source.stack_id)
      const [card] = source_stack.cards.splice(source.card_index, 1)
      moved_card = card  /* store the card for later use */

      /* same row handling */
      if (source.row === target.row) {
        if (target.stack_id) {
          const target_stack = updated_state.stacks.find(s => s.id === target.stack_id)
          const insert_index = source.stack_id !== target.stack_id 
            ? target.card_index + 1 
            : target.card_index
          target_stack.cards.splice(insert_index, 0, card)
        } else {
          create_new_stack(updated_state, card, target.drop_x, target.row)
        }
      }

      /* cleanup empty stacks */
      updated_state.stacks = updated_state.stacks.filter(s => s.cards.length > 0)
      return updated_state
    })

    /* handle different row updates */
    if (source.row !== target.row) {
      /* ensure we have the card before updating target */
      setTimeout(() => {
        target_setter(curr_state => {
          const updated_state = { ...curr_state }
          if (target.stack_id) {
            const target_stack = updated_state.stacks.find(s => s.id === target.stack_id)
            target_stack.cards.splice(target.card_index + 1, 0, moved_card)
          } else {
            create_new_stack(updated_state, moved_card, target.drop_x, target.row)
          }
          return updated_state
        })
      }, 0)
    }
  }

  /* helper for creating a new stack when dropping on a row */
  const create_new_stack = (row_state, card, drop_x, row) => {
    if (row_state.stacks.length === 0) {
      row_state.stacks.push({
        id: get_unique_stack_id(row_state),
        cards: [card]
      })
      return
    }

    const stack_positions = row_state.stacks
      .map(stack => ({
        stack,
        position: get_stack_position(row, stack.id)
      }))
      .filter(item => item.position !== null)

    const nearest = stack_positions.reduce((a, b) => 
      Math.abs(a.position.center - drop_x) < Math.abs(b.position.center - drop_x) ? a : b
    )

    const new_stack = {
      id: get_unique_stack_id(row_state),
      cards: [card]
    }

    const nearest_index = row_state.stacks.findIndex(s => s.id === nearest.stack.id)
    const insert_index = drop_x > nearest.position.center ? nearest_index + 1 : nearest_index
    row_state.stacks.splice(insert_index, 0, new_stack)
  }





	/* CONTEXT/PROVIDER BOILERPLATE */

  const value = {
    rows: [
      { id: 'top', ...top_row },
      { id: 'left', ...left_row }, 
      { id: 'right', ...right_row }
    ],
    handlers,
    register_stack_ref
  }

  return (
    <BoardStateContext.Provider value={value}>
      {children}
    </BoardStateContext.Provider>
  )
}
